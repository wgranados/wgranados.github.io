---
layout: default-tut 
---
<div>
  <p style="font-weight: 900;font-size: -webkit-xxx-large;text-align: center;">Welcome to CSCA48</p>
  <p class="txt-style"><b>TA name:</b> William Granados</p>
  <p class="txt-style"><b>Tutorial:</b> Wednesday 4-5pm, at BV 264 </p>
  <p class="txt-style"><b>Practical:</b> Monday 4-5pm, at BV 471 </p>
  <p class="txt-style"><b>Email Policy:</b> Before emailing me, consider attending my practical or posting the question on <a href = "https://piazza.com/mail.utoronto.ca/fall2017/csca08">Piazza</a>. My email address is <a href="mailto:william.granadosmatamoros@mail.utoronto.ca?subject=CSCA48">william.granadosmatamoros@mail.utoronto.ca</a>. When emailing me, use your utoronto email and in the subject include "CSCA48".</p>
  <p class="txt-style"><b>Expectations:</b> There may be a <i>quiz</i> held in tutorial, so please be on time. </p> 
</div>

<div id="accordion">
    <!--div class="card">
      <div class="card-header" id="heading2">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse2" aria-expanded="true" aria-controls="collapse3">
              Week 3: September 19th - Python Memory Model
          </button>
        </h5>
      </div>
  
      <div id="collapse2" class="collapse show" aria-labelledby="heading2" data-parent="#accordion">
        <div class="card-body">
          <ul> Enter stuff here
          </ul>
        </div>
      </div>
    </div-->

    <div class="card">
      <div class="card-header" id="heading11">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse11" aria-expanded="true" aria-controls="collapse11">
            Week 12: April 3rd - Sorting Algorithms
          </button>
        </h5>
      </div>
  
      <div id="collapse11" class="collapse show" aria-labelledby="heading11" data-parent="#accordion">
        <div class="card-body">
            <ul>
                We went over several sorting algorithms, and you should be able to simulate them after N passes of each algorithm. This is the last tutorial so <b>good luck on final exams!</b>
                <br>

                <li class="txt-style">Bubble Sort</li>
                <ul>
                    <li>General Idea: You want to loop through the array and swap adjacent pairs of numbers if they're out of place. Then repeat this process N times.</li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/bubble-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(n)$ to swap the elemens in the inside loop, $O(n)$ for the outer loop, resulting in $O(n^2)$.</li>
                </ul>
                <li class="txt-style">Selection Sort</li>
                <ul>
                    <li>General Idea: In N successful passes of the unsorted array, select the minimum element, remove it, then append it to your sorted list.</li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/selection-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(n)$ to find the minimum element, $O(n)$ for the passes,resulting in $O(n^2)$.</li>
                </ul>
                <li class="txt-style">Insertion Sort</li>
                <ul>
                    <li>General Idea: Assume the first element is a sorted sequence, starting from the second element, you find its position in the sorted portion to the left. </li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/insertion-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(n)$ to loop over all the elements, $O(n)$ to find its place , resulting in $O(n^2)$.</li>
                </ul>
                <li class="txt-style">Heap Sort</li>
                <ul>
                    <li>General Idea: Put all of the elements into a heap, then successfully pop the minimum element. </li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/heap-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(\log{n})$ for popping min , $O(n)$ repeating process on n elements, resulting in $O(n\log{n})$.</li>
                </ul>
                <li class="txt-style">Quick Sort</li>
                <ul>
                    <li>General Idea: Choose a pivot location (usually the median), move elements smaller than the pivot to the left half of the array, and elements greater to the right half. Then call quick sort on each half.</li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/quick-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(n\log{n})$, more <a href="https://www.khanacademy.org/computing/computer-science/algorithms/quick-sort/a/analysis-of-quicksort">complicated</a></li>
                </ul>
                <li class="txt-style">Merge Sort</li>
                <ul>
                    <li>General Idea: Continually split array into halves, call merge sort on both halves, then combine the sorted subproblems.</li>
                    <li>Implementation: <a href="https://www.geeksforgeeks.org/merge-sort/">geeksforgeeks</a></li>
                    <li>Time Complexity:  $O(n\log{n})$ using Master Theorem</li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading10">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse10" aria-expanded="true" aria-controls="collapse10">
            Week 11: March 28th - Analying Time Complexity of Recursive Algorithms
          </button>
        </h5>
      </div>
  
      <div id="collapse10" class="collapse" aria-labelledby="heading10" data-parent="#accordion">
        <div class="card-body">
            <ul>
                <li class="txt-style">Big-Oh for recursion</li>
                <ul>
                    <li>It might be a bit easier to count the number of steps in for a, for loop, but a recursive function is a lot more complex.</li>
                    <li>Remember, at the end of the day we have to base the run time on the parameters, be it nodes in a tree, or some numerical value.</li>
                    <li>In general there are 3 types of recursive algorithms that you study, and it's a requires some foresight to figure out the runtime.</li>
                    <ul>
                        <li><b>Linear Recursion:</b> These are pretty straightforward. Since it branches linearly, you just have to count the number of overall recursive calls, and whatever happens in the function.</li>
                        <li><b>General Recursion:</b> These are a bit tougher, since they involve several branches per recursive call, and finding an upper bound on this requires some pattern matching.  </li>
                        <li><b>Divide & Conquer Recursion:</b>  You won't have to analyze these types for this course, but you you can cheat by using the <a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">Master Theorem</a>! <br> This approach involves learning about recurrences <b>which is not required for this course.</b></li>
                    </ul>
                </ul>
                <li class="txt-style">Linear Recursion</li>
                <ul>
                    <li>Usually should be $O(n)$ unless there's sufficient work being done inside each call.</li>
                </ul>
                <li class="txt-style">General Recursion</li>
                <ul>
                    <li>For these types of recursion, in general you will be in one of two cases.</li>
                    <ul>
                        <li>Each recursive call is unique, and is only called once. An example would be <a href="https://en.wikipedia.org/wiki/Flood_fill">flood fill</a>, so figuring out the input size is easy.</li>
                        <li>Each recursive call isn't necessarily unique. An example is <a href="https://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">naive fibonacci calculation</a>, in this case if you were to draw out the recursion tree <br> you'd notice it was exponential with respect to the recursive branches. I.e. $O(2^n)$ for this case.</li>

                    </ul>
                </ul>
                <li class="txt-style">Divide & Conquer Recursion</li>
                <ul>
                    <li>These are a lot more difficult and show up in CSCC73 (Algorithm Design), so you won't have to worry about them too much. </li>
                    <li>Algorithms like quick sort and merge sort are generally analyzed using the <a href="https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms)">Master Theorem</a> <b>which you don't have to know for this course.</b></li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading9">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse9" aria-expanded="true" aria-controls="collapse9">
            Week 10: March 20th - Time Complexity
          </button>
        </h5>
      </div>
  
      <div id="collapse9" class="collapse" aria-labelledby="heading9" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's some extra notes on the <a href="https://drive.google.com/file/d/0Bz8sftGywZGxbF95QmppN2k4OUk/view?usp=sharing">topic</a>.
                <br>
                <b>TT2 will be handed back today.</b>
                <li class="txt-style">Big-Oh</li>
                <ul>
                    <li>When measuring the efficiency of algorithms, you measure it by the amount of steps it takes to termination. <br> For example, the line <code>for i in range(0, n)</code> takes n steps to terminate.</li>
                    <li>For most algorithms you write, you can model the amount of steps by a mathematical function with respect to the amount of steps taken.</li>
                    <li>The notation $O(g(n))$ basically says that whatever algorithm you write is bounded above by $g(n)$ at some point. <br> I.e. in the worst case, your algorithm takes this amount of steps.</li>

                </ul>


                <li class="txt-style">Time Complexity Hierarchy</li>
                <ul>
                    <li>It's important to have some kind of intuition for the hierarchy of time complexity when it comes to algorithms, here are some helpful examples.</li>
                    <ul>
                    <li>$O(1)$ - some examples are: arithmetic operations, appending to the back of the list.</li>
                    <li>$O(log(n))$ - some examples are: inserting into a heap, binary search.</li>
                    <li>$O(n)$ - an example is a simple for loop that loops n times.</li>
                    <li>$O(n^d), d > 1$ - an example is having <code>d</code> nested for loops each looping n times.</li>
                    <li>$O(b^n), b > 1$ -  generally you get this when you're doing recursion.</li>
                    <li>$O(n!)$  -  generally you get this when you're generating permutations or something similar.</li>
                    </ul>
                </ul>

                <li class="txt-style">Formal Definition</li>
                <ul>
                    <li>You might be asked to prove something like $5n^4 + 3n^3 + 2n^2 + 4n + 1 \in O(n^4)$</li>
                    <li>You start off the proof by stating : $f(n) \in O(g(n)) \iff \exists c > 0, \exists n_0 > 0 , s.t \, \forall n > n_o, f(n) \leq c \cdot g(n)$</li>
                    <li>The above is a bit confusing, so lets break it down a little.</li>
                    <ul>
                        <li>Essentially what we're trying to prove is that, if we were to graph both functions, after some point $n_0$, $g(n)$ be bigger than $f(n)$, for all n greater than $n_0$</li>
                        <li>You can make this task easier by also scaling $g(n)$ by some constant $c$</li>
                    </ul>
                    <li>For the above formula, if you substitute $n_0 = 1, c = 15$, then you get $15 \leq 15$, and your proof is done.</li>
                </ul>

                <li class="txt-style">Challenge problem</li>
                <ul>
                    <li>Describe an algorithm for finding the 10 biggest elements in an unsorted array of size <code>N</code>.</li>
                    <li>Send me an email with your solution(code) and time complexity analysis, and if you have the fastest asymptotic time algorithm, we'll post your name on piazza.</li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading8">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse8" aria-expanded="true" aria-controls="collapse8">
            Week 9: March 13th - Recursion Examples
          </button>
        </h5>
      </div>
  
      <div id="collapse8" class="collapse" aria-labelledby="heading8" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the code sample we went over <a href="tut2/example.txt">example</a>, <a href="tut2/graphics.txt">graphics</a>.
                <br>
                <li class="txt-style">Recursion Challenges</li>
                <ul>
                    <li>With the above code try and create a recursive drawing, in the example we made a recursive H-tree structure.</li>
                    <li>Here are some optional problems with a similar flavour: <a href="https://wcipeg.com/problem/ccc99s3">Divided Fractals</a>, <a href="https://wcipeg.com/problem/ccc11s3">Alice Through the Looking Glass</a></a></li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading7">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse7" aria-expanded="true" aria-controls="collapse7">
            Week 8: March 7th - Recursion
          </button>
        </h5>
      </div>
  
      <div id="collapse7" class="collapse" aria-labelledby="heading7" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the code sample we went over <a href="/tut2/vowel_count.txt">vowel_count</a>.
                <br>
                <b>Last day to pick up midterm from tutorial. Pickup will now be done from Marzieh's office.</b>
                <li class="txt-style">Recursion</li>
                <ul>
                    <li>Did you mean: <a href="https://www.google.ca/search?q=recursion&rlz=1C5CHFA_enCA742CA742&oq=recursion&aqs=chrome..69i57j69i60j0l4.1024j0j7&sourceid=chrome&ie=UTF-8">recursion?</a></li>
                    <li>Problems that branch out lend themselves easier to a recursive solution that one that involves loops and if statements.</li>
                    <li>When designing a recursive function you think about the <b>parameters</b>, the <b>base case</b>, the <b>recursive case</b>, and the <b>combining step</b>.</li>
                    <ul>
                        <li>The parameters are what is generally gonna change on each recursive call, they're essentially the problem you're trying to break down</li>
                        <li>The recursive case is how you're gonna break the problem down.</li>
                        <li>The base case is once you've found the solution to a broken down problem.</li>
                        <li>The combining step is how you're gonna combine the solutions found from the broken down problems.</li>
                    </ul>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading6">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse6" aria-expanded="true" aria-controls="collapse6">
                Week 7: Feb 28th - Binary Heaps
          </button>
        </h5>
      </div>
  
      <div id="collapse6" class="collapse" aria-labelledby="heading6" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the code sample we went over <a href="https://mathlab.utsc.utoronto.ca/courses/csca48/Codes/week6_heap.py">week6_heap</a>, <a href="https://mathlab.utsc.utoronto.ca/courses/csca48/Codes/week3_pq.py">week3_pq</a>. From last time you can read the heap section on these extra <a href="https://drive.google.com/file/d/0Bz8sftGywZGxYzFKVm82QVVTSlE/view?usp=sharing">notes</a>.
                <br>
                <b>TT1 will be returned today.</b>
                <li class="txt-style">Priority Queue ADT</li>
                <ul>
                    <li><code>min</code> or <code>max</code> amongst all elements in the container.</li>
                    <li><code>insert</code> and <code>delete</code> elements into the container.</li>
                </ul>
                <li class="txt-style">Binary Heap Representation Invariant and properties</li>
                <ul>
                    <li>Internally represented with a list, <code>heap</code>, where <code>heap[:]</code> contains the elements.</li>
                    <li><code>heap[0]</code> contains the overall min/max element</li>
                    <li>for all <code>i</code> on a max heap, <code>heap[i] < heap[2*i+1]</code> and <code>heap[i] < heap[2*i+2]</code>. Same applies for max heaps but <code>heap[i]</code> is bigger.</li>
                    <li>abstractly the heap represents a complete tree with <code>n</code> nodes. So the maximum height of the tree is about <code>log(n)</code></li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading5">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse5" aria-expanded="true" aria-controls="collapse5">
            Week 5: Feb 14th - Binary Search Tree (BST)
          </button>
        </h5>
      </div>
  
      <div id="collapse5" class="collapse" aria-labelledby="heading5" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the code sample we went over in <a href="https://mathlab.utsc.utoronto.ca/courses/csca48/Codes/week5_BST.py">here</a>, and here are some extra <a href="https://drive.google.com/file/d/0Bz8sftGywZGxYzFKVm82QVVTSlE/view?usp=sharing">notes</a>. Note that the way deletion is done in these notes is <b>incorrect</b> for this course.
                <li class="txt-style">Binary Search Trees Properties</li>
                <ul>
                    <li>Has a tree-like structure to it </li>
                    <li>Each node has at most 2 children</li>
                    <li>Invariant: for any node <code>u</code>, <code>u</code> is greater than all of its left descendents, <code>u</code> is less than all of its right descendents</li>
                </ul>
                <li class="txt-style">Insertions</li>
                <ul>
                    <li>Traverse down the tree until you get to an empty node</li>
                    <li>When you traverse, compare the value you want to insert with the node you're currently at. If your node is bigger, go right, otherwise go left.</li>
                </ul>
                <li class="txt-style">Deletion</li>
                <ul>
                    <li>Four cases to consider based on how many children the node has.</li>
                    <li>0 children: just delete the node, don't have to worry about the invariant</li>
                    <li>1 child: just replace the node with it's child, the invariant holds</li>
                    <li>2 children: replace the node to delete, with the leftmost child in its right subtree</li>
                </ul>

                <li class="txt-style">Traversals</li>
                <ul>
                    <li>Basically define in what manner we're going to traverse and print the values of the tree. There are 3 you should know.</li>
                    <li>Pre-order: Node Left Right (NLR), In-order: Left Node Right (LNR), Post-order: Left Right Node (LRN).</li>
                    <li>General tip when you're doing this problems is to write the letters of the alphabet to help you reason faster.</li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading4">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse4" aria-expanded="true" aria-controls="collapse4">
            Week 4: Feb 7th - Double Linked List (DLL)
          </button>
        </h5>
      </div>
  
      <div id="collapse4" class="collapse" aria-labelledby="heading4" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here are the code sample gone over in class: <a href="tut2/indexed_dll.txt">indexed_dll</a>, <a href="tut2/week4_DLL.txt">week4_DLL</a>.
                <li class="txt-style">Efficiency</li>
                <ul>
                    <li>Compared to the single linked list (SLL), removing elements from the back or front are constant instead of requiring one traversal.</li>
                    <li>A lot easier to perform logic with respect to adding/deleting nodes</li>
                </ul>
                <li class="txt-style">Augmenting</li>
                <ul>
                    <li>Your challenge is to augment the DLL data structure, to incorporate the following functionality
                        <ul>
                            <li><code>insert(e,i)</code> - <code>e</code> is an element and <code>i</code> is the index where it should be inserted.</li>
                            <li><code>remove(i)</code> - <code>i</code> is the index of the node to be removed.</li>
                        </ul>
                    </li>
                    <li>Your solution should make use of the provided week4_DLL file above. It must make use of OOP principles.</li>
                    <li>Make sure you understand how traversals works with DLL, and making use of get/set functions provided by the node class</li>
            </ul>
        </div>
      </div>
    </div>

    <div class="card">
      <div class="card-header" id="heading3">
        <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse3" aria-expanded="true" aria-controls="collapse3">
            Week 3: January 31st - Deque
          </button>
        </h5>
      </div>
  
      <div id="collapse3" class="collapse" aria-labelledby="heading3" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the code sample gone over in class: <a href="tut2/deque.txt">deque</a>.
                <li class="txt-style">Properties & Applications</li>
                <ul>
                    <li>Supports inserting or popping elements from either side of the ADT in constant time.</li>
                    <li>Essentially combines the functionality of both a queue and stack.</li>
                    <li>Used in some OS Scheduling Algorithms like the <a href="https://en.wikipedia.org/wiki/Work_stealing">A-Steal</a> scheduling algorithm.</li>
                </ul>
            </ul>
        </div>
      </div>
    </div>

<div class="card">
    <div class="card-header" id="heading2">
      <h5 class="mb-0">
          <button class="btn btn-link" data-toggle="collapse" data-target="#collapse2" aria-expanded="true" aria-controls="collapse2">
            Week 2: January 24th - Stack Applications
          </button>
        </h5>
      </div>
  
      <div id="collapse2" class="collapse" aria-labelledby="heading2" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's are the code samples gone over in class: <a href="tut2/decimal_to_binary.txt">decimal_to_binary</a>, <a href="tut2/StackADT_v1.txt">StackADT</a>. And an extra problem we went over <a href="https://www.geeksforgeeks.org/check-for-balanced-parentheses-in-an-expression/">Parenthesis</a>.
                <li class="txt-style">Decimal to Binary</li>
                <ul>
                    <li>Here's more than enough information you need to know about representing numbers in different bases <a href="https://drive.google.com/file/d/0Bz8sftGywZGxOTNEUnMxd09GQ0U/view?usp=sharing">Computer Number Systems</a></li>
                    <li>You only need to understand how to convert decimal to binary numbers for the first example.</li>
                </ul>
                <li class="txt-style">Applications</li>
                <ul>
                    <li>Think about how the data is structured, and how you want to access it. This will help you work through problems.</li>
                    <li>Remember that Stacks provide you data in a LIFO(Last In First Out) fashion which differs from how a queue does it in a FIFO(First in First Out) fashion.</li>
                    <li>Here's a list of fun (optional) problems involving stacks: <a href="http://wcipeg.com/problem/ccc14s3">Geneva Confection</a>, <a href="http://wcipeg.com/problem/boi09p4">Frog Mutants</a> </li>
                </ul>
            </ul>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header" id="heading1">
        <h5 class="mb-0">
          <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapse1" aria-expanded="false" aria-controls="collapse1">
            Week 1: January 18th - Abstract Data Types (ADT)
          </button>
        </h5>
      </div>
      <div id="collapse1" class="collapse" aria-labelledby="heading1" data-parent="#accordion">
        <div class="card-body">
            <ul>
                Here's the <a href="tut2/week1_vector.txt">code</a> we went over.
                <li class="txt-style">Abstract Data Types</li>
                <ul>
                    <li> Is a logical description of how we view data and the operations that are allowed <strong>without regard to how they will be implemented</strong> (<a href="http://interactivepython.org/runestone/static/pythonds/Introduction/WhyStudyDataStructuresandAbstractDataTypes.html">source</a>). </li>
                    <li> Understand how behaviour can change based on the type of data that we provide. </li>
                    <li> Note that if certain conditions aren't satisfied for our ADT, we should throw an exception. </li>
                    <li> Generally docstrings and method signatures shouldn't change when implementing an ADT. </li>
                </ul>
            </ul>
        </div>
      </div>
    </div>
    <div class="card">
      <div class="card-header" id="heading0">
        <h5 class="mb-0">
          <button class="btn btn-link collapsed" data-toggle="collapse" data-target="#collapse0" aria-expanded="false" aria-controls="collapse0">
            Week 0: January 10th
          </button>
        </h5>
      </div>
      <div id="collapse0" class="collapse" aria-labelledby="heading0" data-parent="#accordion">
        <div class="card-body">
            There are no tutorials this week. Instead here's a link to a funny comic <a href="https://xkcd.com/835/">XKCD - Trees</a>.
        </div>
      </div>
    </div>
  </div>